[TOC]

# 2.1. The Importance of Metaphors

Comparing a topic you understand poorly to something similar you understand better results in a better understanding of the less-familiar topic. This use of metaphor is called **modeling**.

In general, the power of models is that they're **vivid** and can be grasped as **conceptual wholes**. They suggest properties, relationships, and additional areas of inquiry.

> A good metaphor is simple, relates well to other relevant metaphors, and explains much of the experimental evidence and other observed phenomena.

Metaphors contribute to a greater understanding of software development issues in the same way that they contribute to a greater understanding of scientific questions.

Once the old theory has been discarded, it seems incredible that anyone ever believed it at all. More fantastically, people who believed the old theory thought the new theory was just as ridiculous then as you think the old theory is now.

The history of science isn't the series of switches from the "wrong" metaphor to the "right" one, but **from "worse" metaphors to "better" ones**, from less inclusive to more inclusive, from suggestive in one area to suggestive in another. In fact, many old models that have been replaced by better models are still useful.

Software development is a young field and not yet mature enough to have a set of standard metaphors. Consequently, it has a **profusion of complementary and conflicting metaphors**. Some are better than others. Some are worse. **How well you understand the metaphors determines how well you understand software development**.

# 2.2. How to Use Software Metaphors

A software metaphor doesn't tell you where to find the answer, it tells you **how to look for it**, it serves more as a **heuristic** than an algorithm.

Having directions that told you exactly how to solve your programming problems would certainly make programming easier and the results more predictable. But programming science isn't yet that advanced and may never be. The most challenging part of programming is **conceptualizing** the problem. Thus, knowing **how to approach problems in general** is at least as valuable as knowing specific solutions for specific problems.

Use software metaphors to give you insight into your programming problems and processes, to help you think about your programming activities and to help you imagine better ways of doing things.

# 2.3. Common Software Metaphors

## Software Penmanship: Writing Code

The "writing code" metaphor suggests that developing a program is like writing a casual letter - you sit down with pen, ink, and paper and write it from start to finish. It doesn't require any formal planning, and you figure out what you want to say as you go.

For an individual's work or for small-scale projects, the letter-writing metaphor works adequately, but for other purposes it leaves the party early - it doesn't describe software development fully or adequately. **In short, the writing metaphor implies a software development process that's too simple and rigid to be healthy.**

The writing metaphor suggests that the software process relies on expensive trial and error rather than careful planning and design.

> It's easy to grab the brass ring if you can afford to sit on your favorite wooden pony for an unlimited number of spins around the carousel. The trick is to get it the first time around - or to take several chances when they're cheapest.

## Software Farming: Growing a System

Some software developers say you should envision creating software as something like planting seeds and growing crops. You design a piece, code a piece, test a piece, and add it to the system a little bit at a time. By taking small steps, you minimize the trouble you can get into at any one time.

--> Try to keep this technique, and come up with a better metaphor, because the farming analogy is weak and uninformative.

## Software Oyster Farming: System Accretion

Accretion means any growth of increase in size by a gradual external addition or inclusion. It describes the way an oyster makes a pearl, by gradually adding small amounts of calcium carbonate, a slow addition to land by the deposit of waterborne sediment.

Incremental designing, building and testing are some of the most powerful software development concepts available: you first make simplest version of the system that will run, i.e. a skeleton strong enough to hold the real system as it's developed. Then little by little you lay on the muscle and skin.

## Software Construction: Building Software

Building sofware implies various stage of planning, preparation, and execution that vary in kind and degree depending on what's being built.

> The larger the project is, the more complicated the building process will be, and so are the consequences of poor design.

Building a software system is like building a large house: you'll reuse high-level language features, prebuilt libraries, etc. It generally doestn't make sense to code things you can buy ready-made.

The customization has parallels in software development.

> A well-planned project improves your ability to change your mind later about details.

Different software projects benefit from different development approaches. You might generally use flexible, lightweight ones, but sometimes you'll need rigid, heavyweight ones to achieve safety goals and other goals.

Making structural changes in a program costs more than adding or deleting peripheral features.

> In extremely large project: it's better to pay 10% more for stronger material than to have a skycraper fall over.

## Applying Software Techniques: The Intellectual Toolbox
## Combining Metaphors

# Additional Resources

- Kuhn, Thomas S. *The Structure of Scientific Revolutions*, 3rd Edition Chicago, IL: The University of Chicago Press, 1996.
- Floyd, Robert W. *The Paradigms of Programming* 1978, *Communications of the ACM* 1979.